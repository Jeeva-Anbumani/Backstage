import React from 'react';
import { V1ObjectMeta, V1PersistentVolumeClaimTemplate, V1ConfigMap, V1Secret } from '@kubernetes/client-node';

type StackedValue = {
    color: string;
    name: string;
    size: number;
};
type HorizontalStackedBarsProps = {
    id: string;
    barGap?: number;
    height?: number | string;
    inline?: boolean;
    values: StackedValue[];
    width?: number | string;
    onClick?: () => void;
};
declare const HorizontalStackedBars: ({ id, barGap, height, inline, values, width, onClick, }: HorizontalStackedBarsProps) => React.JSX.Element;

type CamelCaseWrapProps = {
    value: string;
    dataTest?: string;
};
declare const CamelCaseWrap: ({ value, dataTest }: CamelCaseWrapProps) => any;

type TektonParam = {
    default?: string | string[];
    description?: string;
    name: string;
    type?: string;
};
type TektonResource = {
    name: string;
    optional?: boolean;
    type: string;
};
type TektonWorkspace = {
    name: string;
    description?: string;
    mountPath?: string;
    readOnly?: boolean;
    optional?: boolean;
};
type TektonResourceGroup<ResourceType> = {
    inputs?: ResourceType[];
    outputs?: ResourceType[];
};
type TektonTaskSteps = {
    name: string;
    args?: string[];
    command?: string[];
    image?: string;
    resources?: {}[] | {};
    env?: {
        name: string;
        value?: string;
    }[];
    script?: string;
    workingDir?: string;
    volumeMounts?: {
        name: string;
        mountPath: string;
    }[];
};
type TaskResult = {
    name: string;
    description?: string;
};
type TektonTaskSpec = {
    metadata?: {};
    description?: string;
    steps: TektonTaskSteps[];
    params?: TektonParam[];
    resources?: TektonResourceGroup<TektonResource>;
    results?: TaskResult[];
    workspaces?: TektonWorkspace[];
};
type TektonResultsRun = {
    name: string;
    type?: string;
    value: string;
};
type PipelineTaskRef = {
    kind?: string;
    name: string;
};
type PipelineTaskWorkspace = {
    name: string;
    workspace: string;
    optional?: boolean;
};
type PipelineTaskResource = {
    name: string;
    resource?: string;
    from?: string[];
};
type PipelineTaskParam = {
    name: string;
    value: any;
};
type WhenExpression = {
    input: string;
    operator: string;
    values: string[];
};
type PipelineResult = {
    name: string;
    value: string;
    description?: string;
};
type PipelineTask = {
    name: string;
    params?: PipelineTaskParam[];
    resources?: TektonResourceGroup<PipelineTaskResource>;
    runAfter?: string[];
    taskRef?: PipelineTaskRef;
    taskSpec?: TektonTaskSpec;
    when?: WhenExpression[];
    workspaces?: PipelineTaskWorkspace[];
};
type PipelineSpec = {
    params?: TektonParam[];
    resources?: TektonResource[];
    serviceAccountName?: string;
    tasks: PipelineTask[];
    workspaces?: TektonWorkspace[];
    finally?: PipelineTask[];
    results?: PipelineResult[];
};
type Condition = {
    type: string;
    status: string;
    reason?: string;
    message?: string;
    lastTransitionTime?: string;
};
type PipelineKind = {
    apiVersion?: string;
    kind?: string;
    metadata?: V1ObjectMeta;
    spec: PipelineSpec;
};

declare enum TerminatedReasons {
    Completed = "Completed"
}
declare enum ComputedStatus {
    All = "All",
    Cancelling = "Cancelling",
    Succeeded = "Succeeded",
    Failed = "Failed",
    Running = "Running",
    'In Progress' = "In Progress",
    FailedToStart = "FailedToStart",
    PipelineNotStarted = "PipelineNotStarted",
    Skipped = "Skipped",
    Cancelled = "Cancelled",
    Pending = "Pending",
    Idle = "Idle",
    Other = "Other"
}
declare enum SucceedConditionReason {
    PipelineRunCancelled = "StoppedRunFinally",
    PipelineRunStopped = "CancelledRunFinally",
    TaskRunCancelled = "TaskRunCancelled",
    Cancelled = "Cancelled",
    PipelineRunStopping = "PipelineRunStopping",
    PipelineRunPending = "PipelineRunPending",
    TaskRunStopping = "TaskRunStopping",
    CreateContainerConfigError = "CreateContainerConfigError",
    ExceededNodeResources = "ExceededNodeResources",
    ExceededResourceQuota = "ExceededResourceQuota",
    ConditionCheckFailed = "ConditionCheckFailed"
}
type StatusMessage = {
    message: string;
    color: string;
};
type TaskStatusTypes = {
    PipelineNotStarted: number;
    Pending: number;
    Running: number;
    Succeeded: number;
    Cancelled: number;
    Failed: number;
    Skipped: number;
};

type PLRTaskRunStep = {
    container: string;
    imageID?: string;
    name: string;
    waiting?: {
        reason: string;
    };
    running?: {
        startedAt: string;
    };
    terminated?: {
        containerID: string;
        exitCode: number;
        finishedAt: string;
        reason: string;
        startedAt: string;
        message?: string;
    };
};
type PipelineRunParam = {
    name: string;
    value: string | string[];
    input?: string;
    output?: string;
    resource?: object;
};
type PipelineRunWorkspace = {
    name: string;
    [volumeType: string]: {};
};
type PipelineRunEmbeddedResourceParam = {
    name: string;
    value: string;
};
type PipelineRunEmbeddedResource = {
    name: string;
    resourceSpec: {
        params: PipelineRunEmbeddedResourceParam[];
        type: string;
    };
};
type PipelineRunReferenceResource = {
    name: string;
    resourceRef: {
        name: string;
    };
};
type PipelineRunResource = PipelineRunReferenceResource | PipelineRunEmbeddedResource;
type PLRTaskRunData = {
    pipelineTaskName: string;
    status?: {
        completionTime?: string;
        conditions: Condition[];
        podName: string;
        startTime: string;
        steps?: PLRTaskRunStep[];
        taskSpec?: TektonTaskSpec;
        taskResults?: {
            name: string;
            value: string;
            type?: string;
        }[];
    };
};
type PLRTaskRuns = {
    [taskRunName: string]: PLRTaskRunData;
};
type PipelineRunStatus = {
    succeededCondition?: string;
    creationTimestamp?: string;
    conditions?: Condition[];
    startTime?: string;
    completionTime?: string;
    taskRuns?: PLRTaskRuns;
    pipelineSpec: PipelineSpec;
    skippedTasks?: {
        name: string;
    }[];
    pipelineResults?: TektonResultsRun[];
    results?: TektonResultsRun[];
};
type PipelineRunKind = {
    apiVersion?: string;
    kind?: string;
    metadata?: V1ObjectMeta;
    spec: {
        pipelineRef?: {
            name: string;
        };
        pipelineSpec?: PipelineSpec;
        params?: PipelineRunParam[];
        workspaces?: PipelineRunWorkspace[];
        resources?: PipelineRunResource[];
        serviceAccountName?: string;
        timeout?: string;
        status?: string;
    };
    status?: PipelineRunStatus;
};
type PipelineTaskWithStatus = PipelineTask & {
    status: {
        reason: string;
        completionTime?: string;
        conditions: Condition[];
        podName?: string;
        startTime?: string;
        steps?: PLRTaskRunStep[];
        taskSpec?: TektonTaskSpec;
        taskResults?: {
            name: string;
            value: string;
        }[];
        duration?: string;
    };
};

type VolumeTypePVC = {
    claimName: string;
};
type TaskRunWorkspace = {
    name: string;
    volumeClaimTemplate?: V1PersistentVolumeClaimTemplate;
    persistentVolumeClaim?: VolumeTypePVC;
    configMap?: V1ConfigMap;
    emptyDir?: {};
    secret?: V1Secret;
    subPath?: string;
};
type TaskRunStatus = {
    completionTime?: string;
    conditions?: Condition[];
    podName?: string;
    startTime?: string;
    steps?: PLRTaskRunStep[];
    taskResults?: TektonResultsRun[];
    results?: TektonResultsRun[];
};
type TaskRunKind = {
    apiVersion?: string;
    kind?: string;
    metadata?: V1ObjectMeta;
    spec: {
        taskRef?: PipelineTaskRef;
        taskSpec?: TektonTaskSpec;
        serviceAccountName?: string;
        params?: PipelineTaskParam[];
        resources?: TektonResource[] | {};
        timeout?: string;
        workspaces?: TaskRunWorkspace[];
    };
    status?: TaskRunStatus;
};

interface TaskStatusToolTipProps {
    taskStatus: TaskStatusTypes;
}
declare const TaskStatusTooltip: ({ taskStatus }: TaskStatusToolTipProps) => React.JSX.Element;

type StatusIconAndTextProps = {
    title: string;
    iconOnly?: boolean;
    className?: string;
    icon: React.ReactElement;
    spin?: boolean;
};
declare const StatusIconAndText: ({ icon, title, spin, iconOnly, className, }: StatusIconAndTextProps) => React.ReactElement;

declare const pipelineGroupColor = "#38812f";

declare const skippedColor = "#8a8d90";
declare const cancelledColor = "#6a6e73";
declare const pendingColor = "#8bc1f7";
declare const runningColor = "#06c";
declare const successColor = "#38812f";
declare const failureColor = "#c9190b";

/**
 * Returns the given date as a formated Date.
 *
 * @param date - The given date in seconds
 * @return The date formatted to en-US locale, otherwise return 'N/A'
 */
declare function formatDate(date: string | number | Date | undefined): string;

declare const getRunStatusColor: (status: string) => StatusMessage;
declare const getLatestPipelineRun: (runs: PipelineRunKind[], field: string) => PipelineRunKind | null;
declare const pipelineRunStatus: (pipelineRun: PipelineRunKind | TaskRunKind | PipelineTaskWithStatus | null) => ComputedStatus | null;
declare const pipelineRunFilterReducer: (pipelineRun: PipelineRunKind | TaskRunKind) => ComputedStatus;
declare const updateTaskStatus: (pipelinerun: PipelineRunKind | null, taskRuns: TaskRunKind[]) => TaskStatusTypes;
declare const totalPipelineRunTasks: (pipelinerun: PipelineRunKind | null) => number;
declare const getTaskStatus: (pipelinerun: PipelineRunKind, taskRuns: TaskRunKind[]) => TaskStatusTypes;

declare const getTaskRunsForPipelineRun: (pipelinerun: PipelineRunKind | null, taskRuns: TaskRunKind[]) => TaskRunKind[];

/**
 * Returns a given size in bytes formated to the closest to power of 1024
 *
 * @param sizeInBytes - The given size in bytes
 * @return Formated bytes in powers of 1024
 */
declare function formatByteSize(sizeInBytes: number | undefined): string;

declare const downloadLogFile: (data: string, filename: string) => void;

declare const getTitleCase: (str: string) => string;

interface Cancelable {
    cancel(): void;
    flush(): void;
}
declare const useDebounceCallback: <T extends (...args: any[]) => any>(callback: T, timeout?: number, debounceParams?: {
    leading?: boolean;
    trailing?: boolean;
    maxWait?: number;
}) => ((...args: any) => any) & Cancelable;

declare const useDeepCompareMemoize: <T = any>(value: T, stringify?: boolean) => T;

export { CamelCaseWrap, ComputedStatus, Condition, HorizontalStackedBars, PLRTaskRunData, PLRTaskRunStep, PLRTaskRuns, PipelineKind, PipelineResult, PipelineRunEmbeddedResource, PipelineRunEmbeddedResourceParam, PipelineRunKind, PipelineRunParam, PipelineRunReferenceResource, PipelineRunResource, PipelineRunStatus, PipelineRunWorkspace, PipelineSpec, PipelineTask, PipelineTaskParam, PipelineTaskRef, PipelineTaskResource, PipelineTaskWithStatus, PipelineTaskWorkspace, StatusIconAndText, StatusMessage, SucceedConditionReason, TaskResult, TaskRunKind, TaskRunStatus, TaskRunWorkspace, TaskStatusTooltip, TaskStatusTypes, TektonParam, TektonResource, TektonResourceGroup, TektonResultsRun, TektonTaskSpec, TektonTaskSteps, TektonWorkspace, TerminatedReasons, VolumeTypePVC, WhenExpression, cancelledColor, downloadLogFile, failureColor, formatByteSize, formatDate, getLatestPipelineRun, getRunStatusColor, getTaskRunsForPipelineRun, getTaskStatus, getTitleCase, pendingColor, pipelineGroupColor, pipelineRunFilterReducer, pipelineRunStatus, runningColor, skippedColor, successColor, totalPipelineRunTasks, updateTaskStatus, useDebounceCallback, useDeepCompareMemoize };

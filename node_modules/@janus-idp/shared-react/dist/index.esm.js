import React from 'react';
import classNames from 'classnames';
import { format } from 'date-fns';
import { create, createUnitDependencies, unitDependencies } from 'mathjs';
import { saveAs } from 'file-saver';
import { isEqual, debounce } from 'lodash';

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$2 = ".bs-shared-horizontal-stacked-bars {\n  --bar-gap: 3px;\n  display: block;\n  height: 100%;\n  overflow: hidden;\n  width: 100%;\n  cursor: pointer;\n}\n.bs-shared-horizontal-stacked-bars.is-inline {\n  display: inline-block;\n}\n.bs-shared-horizontal-stacked-bars__bars {\n  display: flex;\n  flex-direction: row;\n  height: 100%;\n  outline: none;\n  width: calc(100% + var(--bar-gap));\n}\n.bs-shared-horizontal-stacked-bars__data-bar {\n  --bar-gap-neg: calc(var(--bar-gap) * -1);\n  box-shadow: inset var(--bar-gap-neg) 0 0 #fff;\n  height: 100%;\n  transition: flex-grow 300ms linear;\n}\n";
styleInject(css_248z$2);

const HorizontalStackedBars = ({
  id,
  barGap,
  height,
  inline,
  values,
  width,
  onClick
}) => /* @__PURE__ */ React.createElement(
  "div",
  {
    id: `horizontal-stacked-bars-${id}`,
    "data-testid": `horizontal-stacked-bars-${id}`,
    className: classNames("bs-shared-horizontal-stacked-bars", {
      "is-inline": inline
    }),
    style: { height, width, ["--bar-gap"]: barGap && `${barGap}px` },
    onClick
  },
  /* @__PURE__ */ React.createElement("div", { className: "bs-shared-horizontal-stacked-bars__bars" }, values.map(({ color, name, size }) => /* @__PURE__ */ React.createElement(
    "div",
    {
      key: name,
      className: "bs-shared-horizontal-stacked-bars__data-bar",
      style: {
        background: color,
        flexGrow: size
      }
    }
  )))
);

const MEMO = {};
const CamelCaseWrap = ({ value, dataTest }) => {
  if (!value) {
    return "-";
  }
  if (MEMO[value]) {
    return MEMO[value];
  }
  const words = value.match(/[A-Z]+[^A-Z]*|[^A-Z]+/g);
  const rendered = /* @__PURE__ */ React.createElement("span", { "data-testid": dataTest }, words == null ? void 0 : words.map((word, i) => /* @__PURE__ */ React.createElement(React.Fragment, { key: word }, word, i !== words.length - 1 && /* @__PURE__ */ React.createElement("wbr", null))));
  MEMO[value] = rendered;
  return rendered;
};

var TerminatedReasons = /* @__PURE__ */ ((TerminatedReasons2) => {
  TerminatedReasons2["Completed"] = "Completed";
  return TerminatedReasons2;
})(TerminatedReasons || {});
var ComputedStatus = /* @__PURE__ */ ((ComputedStatus2) => {
  ComputedStatus2["All"] = "All";
  ComputedStatus2["Cancelling"] = "Cancelling";
  ComputedStatus2["Succeeded"] = "Succeeded";
  ComputedStatus2["Failed"] = "Failed";
  ComputedStatus2["Running"] = "Running";
  ComputedStatus2["In Progress"] = "In Progress";
  ComputedStatus2["FailedToStart"] = "FailedToStart";
  ComputedStatus2["PipelineNotStarted"] = "PipelineNotStarted";
  ComputedStatus2["Skipped"] = "Skipped";
  ComputedStatus2["Cancelled"] = "Cancelled";
  ComputedStatus2["Pending"] = "Pending";
  ComputedStatus2["Idle"] = "Idle";
  ComputedStatus2["Other"] = "Other";
  return ComputedStatus2;
})(ComputedStatus || {});
var SucceedConditionReason = /* @__PURE__ */ ((SucceedConditionReason2) => {
  SucceedConditionReason2["PipelineRunCancelled"] = "StoppedRunFinally";
  SucceedConditionReason2["PipelineRunStopped"] = "CancelledRunFinally";
  SucceedConditionReason2["TaskRunCancelled"] = "TaskRunCancelled";
  SucceedConditionReason2["Cancelled"] = "Cancelled";
  SucceedConditionReason2["PipelineRunStopping"] = "PipelineRunStopping";
  SucceedConditionReason2["PipelineRunPending"] = "PipelineRunPending";
  SucceedConditionReason2["TaskRunStopping"] = "TaskRunStopping";
  SucceedConditionReason2["CreateContainerConfigError"] = "CreateContainerConfigError";
  SucceedConditionReason2["ExceededNodeResources"] = "ExceededNodeResources";
  SucceedConditionReason2["ExceededResourceQuota"] = "ExceededResourceQuota";
  SucceedConditionReason2["ConditionCheckFailed"] = "ConditionCheckFailed";
  return SucceedConditionReason2;
})(SucceedConditionReason || {});

function formatDate(date) {
  if (!date || date === -1) {
    return "N/A";
  }
  const adjustedDate = typeof date === "number" ? date * 1e3 : date;
  return format(new Date(adjustedDate), "LLL d, yyyy, h:mm a");
}

const pipelineGroupColor = "#38812f";

const skippedColor = "#8a8d90";
const cancelledColor = "#6a6e73";
const pendingColor = "#8bc1f7";
const runningColor = "#06c";
const successColor = "#38812f";
const failureColor = "#c9190b";

const getTaskRunsForPipelineRun = (pipelinerun, taskRuns) => {
  if (!taskRuns || taskRuns.length === 0) {
    return [];
  }
  const associatedTaskRuns = taskRuns.reduce(
    (acc, taskRun) => {
      var _a, _b, _c, _d;
      if (((_c = (_b = (_a = taskRun == null ? void 0 : taskRun.metadata) == null ? void 0 : _a.ownerReferences) == null ? void 0 : _b[0]) == null ? void 0 : _c.name) === ((_d = pipelinerun == null ? void 0 : pipelinerun.metadata) == null ? void 0 : _d.name)) {
        acc.push(taskRun);
      }
      return acc;
    },
    []
  );
  return associatedTaskRuns;
};

const getRunStatusColor = (status) => {
  switch (status) {
    case ComputedStatus.Succeeded:
      return { message: "Succeeded", color: successColor };
    case ComputedStatus.Failed:
      return { message: "Failed", color: failureColor };
    case ComputedStatus.FailedToStart:
      return {
        message: "PipelineRun failed to start",
        color: failureColor
      };
    case ComputedStatus.Running:
    case ComputedStatus["In Progress"]:
      return { message: "Running", color: runningColor };
    case ComputedStatus.Skipped:
      return { message: "Skipped", color: skippedColor };
    case ComputedStatus.Cancelled:
      return { message: "Cancelled", color: cancelledColor };
    case ComputedStatus.Cancelling:
      return { message: "Cancelling", color: cancelledColor };
    case ComputedStatus.Idle:
    case ComputedStatus.Pending:
      return { message: "Pending", color: pendingColor };
    default:
      return {
        message: "PipelineRun not started yet",
        color: pendingColor
      };
  }
};
const getDate = (run, field) => {
  var _a, _b, _c, _d;
  if (field === "creationTimestamp") {
    return (_b = (_a = run == null ? void 0 : run.metadata) == null ? void 0 : _a.creationTimestamp) != null ? _b : "";
  }
  if (field === "startTime" || field === "completionTime") {
    return (_d = (_c = run == null ? void 0 : run.status) == null ? void 0 : _c[field]) != null ? _d : "";
  }
  return "";
};
const getLatestRun = (runs, field) => {
  let latestRun = runs[0];
  for (let i = 1; i < runs.length; i++) {
    latestRun = new Date(getDate(runs == null ? void 0 : runs[i], field)) > new Date(getDate(latestRun, field)) ? runs[i] : latestRun;
  }
  return latestRun;
};
const getLatestPipelineRun = (runs, field) => {
  if ((runs == null ? void 0 : runs.length) > 0 && field) {
    let latestRun;
    if (field === "completionTime" || field === "startTime" || field === "creationTimestamp") {
      latestRun = getLatestRun(runs, field);
    } else {
      latestRun = runs[runs.length - 1];
    }
    return latestRun;
  }
  return null;
};
const getSucceededStatus = (status) => {
  if (status === "True") {
    return ComputedStatus.Succeeded;
  } else if (status === "False") {
    return ComputedStatus.Failed;
  }
  return ComputedStatus.Running;
};
const pipelineRunStatus = (pipelineRun) => {
  var _a, _b;
  const conditions = ((_a = pipelineRun == null ? void 0 : pipelineRun.status) == null ? void 0 : _a.conditions) || [];
  if (conditions.length === 0)
    return null;
  const succeedCondition = conditions.find((c) => c.type === "Succeeded");
  const cancelledCondition = conditions.find(
    (c) => c.reason === "Cancelled"
  );
  const failedCondition = conditions.find((c) => c.reason === "Failed");
  if ([
    SucceedConditionReason.PipelineRunStopped,
    SucceedConditionReason.PipelineRunCancelled
  ].includes(
    (_b = pipelineRun == null ? void 0 : pipelineRun.spec) == null ? void 0 : _b.status
  ) && !cancelledCondition && !failedCondition) {
    return ComputedStatus.Cancelling;
  }
  if (!(succeedCondition == null ? void 0 : succeedCondition.status)) {
    return null;
  }
  const status = getSucceededStatus(succeedCondition.status);
  if (succeedCondition.reason && succeedCondition.reason !== status) {
    switch (succeedCondition.reason) {
      case SucceedConditionReason.PipelineRunCancelled:
      case SucceedConditionReason.TaskRunCancelled:
      case SucceedConditionReason.Cancelled:
      case SucceedConditionReason.PipelineRunStopped:
        return ComputedStatus.Cancelled;
      case SucceedConditionReason.PipelineRunStopping:
      case SucceedConditionReason.TaskRunStopping:
        return ComputedStatus.Failed;
      case SucceedConditionReason.CreateContainerConfigError:
      case SucceedConditionReason.ExceededNodeResources:
      case SucceedConditionReason.ExceededResourceQuota:
      case SucceedConditionReason.PipelineRunPending:
        return ComputedStatus.Pending;
      case SucceedConditionReason.ConditionCheckFailed:
        return ComputedStatus.Skipped;
      default:
        return status;
    }
  }
  return status;
};
const pipelineRunFilterReducer = (pipelineRun) => {
  const status = pipelineRunStatus(pipelineRun);
  return status || ComputedStatus.Other;
};
const updateTaskStatus = (pipelinerun, taskRuns) => {
  var _a, _b;
  const skippedTaskLength = ((_b = (_a = pipelinerun == null ? void 0 : pipelinerun.status) == null ? void 0 : _a.skippedTasks) == null ? void 0 : _b.length) || 0;
  const PLRTaskRuns = getTaskRunsForPipelineRun(pipelinerun, taskRuns);
  const taskStatus = {
    PipelineNotStarted: 0,
    Pending: 0,
    Running: 0,
    Succeeded: 0,
    Failed: 0,
    Cancelled: 0,
    Skipped: skippedTaskLength
  };
  if (!PLRTaskRuns || PLRTaskRuns.length === 0) {
    return taskStatus;
  }
  PLRTaskRuns.forEach((taskRun) => {
    const status = taskRun && pipelineRunFilterReducer(taskRun);
    if (status === "Succeeded") {
      taskStatus[ComputedStatus.Succeeded]++;
    } else if (status === "Running") {
      taskStatus[ComputedStatus.Running]++;
    } else if (status === "Failed") {
      taskStatus[ComputedStatus.Failed]++;
    } else if (status === "Cancelled") {
      taskStatus[ComputedStatus.Cancelled]++;
    } else {
      taskStatus[ComputedStatus.Pending]++;
    }
  });
  return {
    ...taskStatus
  };
};
const totalPipelineRunTasks = (pipelinerun) => {
  var _a, _b, _c, _d;
  if (!((_a = pipelinerun == null ? void 0 : pipelinerun.status) == null ? void 0 : _a.pipelineSpec)) {
    return 0;
  }
  const totalTasks = (((_b = pipelinerun.status.pipelineSpec) == null ? void 0 : _b.tasks) || []).length;
  const finallyTasks = (_d = (((_c = pipelinerun.status.pipelineSpec) == null ? void 0 : _c.finally) || []).length) != null ? _d : 0;
  return totalTasks + finallyTasks;
};
const getTaskStatus = (pipelinerun, taskRuns) => {
  var _a, _b, _c, _d, _e;
  const totalTasks = totalPipelineRunTasks(pipelinerun);
  const plrTaskLength = taskRuns.length;
  const skippedTaskLength = ((_b = (_a = pipelinerun == null ? void 0 : pipelinerun.status) == null ? void 0 : _a.skippedTasks) == null ? void 0 : _b.length) || 0;
  const taskStatus = updateTaskStatus(pipelinerun, taskRuns);
  if ((taskRuns == null ? void 0 : taskRuns.length) > 0) {
    const pipelineRunHasFailure = taskStatus[ComputedStatus.Failed] > 0;
    const pipelineRunIsCancelled = pipelineRunFilterReducer(pipelinerun) === ComputedStatus.Cancelled;
    const unhandledTasks = totalTasks >= plrTaskLength ? totalTasks - plrTaskLength - skippedTaskLength : totalTasks;
    if (pipelineRunHasFailure || pipelineRunIsCancelled) {
      taskStatus[ComputedStatus.Cancelled] += unhandledTasks;
    } else {
      taskStatus[ComputedStatus.Pending] += unhandledTasks;
    }
  } else if (((_e = (_d = (_c = pipelinerun == null ? void 0 : pipelinerun.status) == null ? void 0 : _c.conditions) == null ? void 0 : _d[0]) == null ? void 0 : _e.status) === "False" || (pipelinerun == null ? void 0 : pipelinerun.spec.status) === SucceedConditionReason.PipelineRunCancelled) {
    taskStatus[ComputedStatus.Cancelled] = totalTasks;
  } else if ((pipelinerun == null ? void 0 : pipelinerun.spec.status) === SucceedConditionReason.PipelineRunPending) {
    taskStatus[ComputedStatus.Pending] += totalTasks;
  } else {
    taskStatus[ComputedStatus.PipelineNotStarted]++;
  }
  return taskStatus;
};

const math = create({ createUnitDependencies, unitDependencies });
const UNITS = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
function formatByteSize(sizeInBytes) {
  if (!sizeInBytes) {
    return "N/A";
  }
  const i = Math.floor(Math.log10(sizeInBytes) / 3);
  const fileSize = math.unit(sizeInBytes, "B").to(UNITS[i]).format({ precision: 3, notation: "auto" });
  return fileSize;
}

const downloadLogFile = (data, filename) => {
  const blob = new Blob([data], { type: "text/log;charset=utf-8" });
  saveAs(blob, filename);
};

const getTitleCase = (str) => str.charAt(0).toUpperCase() + str.substring(1);

var css_248z$1 = ".bs-shared-task-status-tooltip {\n  display: inline-grid;\n  grid-gap: 0.5rem;\n  text-align: left;\n  grid-template-columns: 1rem auto;\n}\n\n.bs-shared-task-status-tooltip__legend {\n  height: 1rem;\n  width: 1rem;\n}\n";
styleInject(css_248z$1);

const TaskStatusTooltip = ({ taskStatus }) => {
  return /* @__PURE__ */ React.createElement("div", { className: "bs-shared-task-status-tooltip" }, Object.keys(ComputedStatus).map((status) => {
    const { message, color } = getRunStatusColor(status);
    return taskStatus[status] ? /* @__PURE__ */ React.createElement(React.Fragment, { key: status }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "bs-shared-task-status-tooltip__legend",
        style: { background: color }
      }
    ), /* @__PURE__ */ React.createElement("div", null, status === ComputedStatus.PipelineNotStarted || status === ComputedStatus.FailedToStart ? message : `${taskStatus[status]} ${message}`)) : null;
  }));
};

var css_248z = ".bs-shared-icon-and-text {\n  align-items: baseline;\n  display: flex;\n  font-weight: 400;\n  font-size: 14px;\n}\n\n.bs-shared-icon-and-text__icon {\n  flex-shrink: 0;\n  margin-right: 5px;\n}\n\n.bs-shared-icon-and-text--lg {\n  display: block;\n}\n\n.bs-shared-icon-and-text--lg .bs-shared-icon-and-text__icon {\n  font-size: 1.2rem;\n  margin-right: 1rem;\n}\n\n.bs-shared-dashboard-icon {\n  font-size: 1.2rem;\n}\n\n.bs-shared-icon-flex-child {\n  flex: 0 0 auto;\n  position: relative;\n  top: 0.125em;\n}\n";
styleInject(css_248z);

const DASH = "-";
const StatusIconAndText = ({
  icon,
  title,
  spin,
  iconOnly,
  className
}) => {
  if (!title) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, DASH);
  }
  if (iconOnly) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, React.cloneElement(icon, {
      "data-testid": `icon-only-${title}`,
      className: icon.props.className
    }));
  }
  return /* @__PURE__ */ React.createElement(
    "span",
    {
      className: classNames("bs-shared-icon-and-text", className),
      "data-testid": `icon-with-title-${title}`,
      title
    },
    React.cloneElement(icon, {
      className: classNames(
        spin && "fa-spin",
        icon.props.className,
        "bs-shared-icon-and-text__icon bs-shared-icon-flex-child"
      )
    }),
    /* @__PURE__ */ React.createElement(CamelCaseWrap, { value: title, dataTest: "status-text" })
  );
};

const useDeepCompareMemoize = (value, stringify) => {
  const ref = React.useRef();
  if (stringify ? JSON.stringify(value) !== JSON.stringify(ref.current) : !isEqual(value, ref.current)) {
    ref.current = value;
  }
  return ref.current;
};

const useDebounceCallback = (callback, timeout = 500, debounceParams = {
  leading: false,
  trailing: true
}) => {
  const memDebounceParams = useDeepCompareMemoize(debounceParams);
  const callbackRef = React.useRef();
  callbackRef.current = callback;
  return React.useMemo(() => {
    return debounce(
      (...args) => {
        var _a;
        return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
      },
      timeout,
      memDebounceParams
    );
  }, [memDebounceParams, timeout]);
};

export { CamelCaseWrap, ComputedStatus, HorizontalStackedBars, StatusIconAndText, SucceedConditionReason, TaskStatusTooltip, TerminatedReasons, cancelledColor, downloadLogFile, failureColor, formatByteSize, formatDate, getLatestPipelineRun, getRunStatusColor, getTaskRunsForPipelineRun, getTaskStatus, getTitleCase, pendingColor, pipelineGroupColor, pipelineRunFilterReducer, pipelineRunStatus, runningColor, skippedColor, successColor, totalPipelineRunTasks, updateTaskStatus, useDebounceCallback, useDeepCompareMemoize };
//# sourceMappingURL=index.esm.js.map

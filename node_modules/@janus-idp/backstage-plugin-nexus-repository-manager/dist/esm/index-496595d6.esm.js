import { createApiRef, createRouteRef, createPlugin, createApiFactory, discoveryApiRef, configApiRef, identityApiRef, createComponentExtension } from '@backstage/core-plugin-api';

const NEXUS_REPOSITORY_MANAGER_CONFIG_ANNOTATIONS = [
  {
    annotation: "nexus-repository-manager/config.title"
  }
];
const NEXUS_REPOSITORY_MANAGER_ANNOTATIONS = [
  {
    annotation: "nexus-repository-manager/docker.image-name",
    query: (str) => ({
      dockerImageName: str
    })
  },
  {
    annotation: "nexus-repository-manager/docker.image-tag",
    query: (str) => ({
      dockerImageTag: str
    })
  },
  {
    annotation: "nexus-repository-manager/docker.layer-id",
    query: (str) => ({
      dockerLayerId: str
    })
  },
  {
    annotation: "nexus-repository-manager/docker.content-digest",
    query: (str) => ({
      dockerContentDigest: str
    })
  }
];
const NEXUS_REPOSITORY_MANAGER_EXPERIMENTAL_ANNOTATIONS = [
  {
    annotation: "nexus-repository-manager/keyword",
    query: (str) => ({
      q: str
    })
  },
  {
    annotation: "nexus-repository-manager/repository",
    query: (str) => ({
      repository: str
    })
  },
  {
    annotation: "nexus-repository-manager/format",
    query: (str) => ({
      format: str
    })
  },
  {
    annotation: "nexus-repository-manager/group",
    query: (str) => ({
      group: str
    })
  },
  {
    annotation: "nexus-repository-manager/name",
    query: (str) => ({
      name: str
    })
  },
  {
    annotation: "nexus-repository-manager/version",
    query: (str) => ({
      version: str
    })
  },
  {
    annotation: "nexus-repository-manager/prerelease",
    query: (str) => ({
      prerelease: str
    })
  },
  {
    annotation: "nexus-repository-manager/md5",
    query: (str) => ({
      md5: str
    })
  },
  {
    annotation: "nexus-repository-manager/sha1",
    query: (str) => ({
      sha1: str
    })
  },
  {
    annotation: "nexus-repository-manager/sha256",
    query: (str) => ({
      sha256: str
    })
  },
  {
    annotation: "nexus-repository-manager/sha512",
    query: (str) => ({
      sha512: str
    })
  },
  {
    annotation: "nexus-repository-manager/conan.base-version",
    query: (str) => ({
      conanBaseVersion: str
    })
  },
  {
    annotation: "nexus-repository-manager/conan.channel",
    query: (str) => ({
      conanChannel: str
    })
  },
  {
    annotation: "nexus-repository-manager/conan.revision",
    query: (str) => ({
      conanRevision: str
    })
  },
  {
    annotation: "nexus-repository-manager/conan.package-id",
    query: (str) => ({
      conanPackageId: str
    })
  },
  {
    annotation: "nexus-repository-manager/conan.package-revision",
    query: (str) => ({
      conanPackageRevision: str
    })
  },
  {
    annotation: "nexus-repository-manager/maven.group-id",
    query: (str) => ({
      mavenGroupId: str
    })
  },
  {
    annotation: "nexus-repository-manager/maven.artifact-id",
    query: (str) => ({
      mavenArtifactId: str
    })
  },
  {
    annotation: "nexus-repository-manager/maven.base-version",
    query: (str) => ({
      mavenBaseVersion: str
    })
  },
  {
    annotation: "nexus-repository-manager/maven.extension",
    query: (str) => ({
      mavenExtension: str
    })
  },
  {
    annotation: "nexus-repository-manager/maven.classifier",
    query: (str) => ({
      mavenClassifier: str
    })
  },
  {
    annotation: "nexus-repository-manager/gavec",
    query: (str) => ({
      gavec: str
    })
  },
  {
    annotation: "nexus-repository-manager/npm.scope",
    query: (str) => ({
      npmScope: str
    })
  },
  {
    annotation: "nexus-repository-manager/npm.author",
    query: (str) => ({
      npmAuthor: str
    })
  },
  {
    annotation: "nexus-repository-manager/npm.description",
    query: (str) => ({
      npmDescription: str
    })
  },
  {
    annotation: "nexus-repository-manager/npm.keywords",
    query: (str) => ({
      npmKeywords: str
    })
  },
  {
    annotation: "nexus-repository-manager/npm.license",
    query: (str) => ({
      npmLicense: str
    })
  },
  {
    annotation: "nexus-repository-manager/npm.tagged-is",
    query: (str) => ({
      npmTaggedIs: str
    })
  },
  {
    annotation: "nexus-repository-manager/npm.tagged-not",
    query: (str) => ({
      npmTaggedNot: str
    })
  },
  {
    annotation: "nexus-repository-manager/nuget.id",
    query: (str) => ({
      nugetId: str
    })
  },
  {
    annotation: "nexus-repository-manager/nuget.tags",
    query: (str) => ({
      nugetTags: str
    })
  },
  {
    annotation: "nexus-repository-manager/nuget.title",
    query: (str) => ({
      nugetTitle: str
    })
  },
  {
    annotation: "nexus-repository-manager/nuget.authors",
    query: (str) => ({
      nugetAuthors: str
    })
  },
  {
    annotation: "nexus-repository-manager/nuget.description",
    query: (str) => ({
      nugetDescription: str
    })
  },
  {
    annotation: "nexus-repository-manager/nuget.summary",
    query: (str) => ({
      nugetSummary: str
    })
  },
  {
    annotation: "nexus-repository-manager/p2.plugin-name",
    query: (str) => ({
      p2PluginName: str
    })
  },
  {
    annotation: "nexus-repository-manager/pypi.classifiers",
    query: (str) => ({
      pypiClassifiers: str
    })
  },
  {
    annotation: "nexus-repository-manager/pypi.description",
    query: (str) => ({
      pypiDescription: str
    })
  },
  {
    annotation: "nexus-repository-manager/pypi.keywords",
    query: (str) => ({
      pypiKeywords: str
    })
  },
  {
    annotation: "nexus-repository-manager/pypi.summary",
    query: (str) => ({
      pypiSummary: str
    })
  },
  {
    annotation: "nexus-repository-manager/rubygems.description",
    query: (str) => ({
      rubygemsDescription: str
    })
  },
  {
    annotation: "nexus-repository-manager/rubygems.platform",
    query: (str) => ({
      rubygemsPlatform: str
    })
  },
  {
    annotation: "nexus-repository-manager/rubygems.summary",
    query: (str) => ({
      rubygemsSummary: str
    })
  },
  {
    annotation: "nexus-repository-manager/yum.architecture",
    query: (str) => ({
      yumArchitecture: str
    })
  },
  {
    annotation: "nexus-repository-manager/yum.name",
    query: (str) => ({
      yumName: str
    })
  }
];

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ApiError extends Error {
  constructor(request, response, message) {
    super(message);
    __publicField$1(this, "url");
    __publicField$1(this, "status");
    __publicField$1(this, "statusText");
    __publicField$1(this, "body");
    __publicField$1(this, "request");
    this.name = "ApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.body = response.body;
    this.request = request;
  }
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _isResolved, _isRejected, _isCancelled, _cancelHandlers, _promise, _resolve, _reject;
class CancelError extends Error {
  constructor(message) {
    super(message);
    this.name = "CancelError";
  }
  get isCancelled() {
    return true;
  }
}
class CancelablePromise {
  constructor(executor) {
    __privateAdd(this, _isResolved, void 0);
    __privateAdd(this, _isRejected, void 0);
    __privateAdd(this, _isCancelled, void 0);
    __privateAdd(this, _cancelHandlers, void 0);
    __privateAdd(this, _promise, void 0);
    __privateAdd(this, _resolve, void 0);
    __privateAdd(this, _reject, void 0);
    __privateSet(this, _isResolved, false);
    __privateSet(this, _isRejected, false);
    __privateSet(this, _isCancelled, false);
    __privateSet(this, _cancelHandlers, []);
    __privateSet(this, _promise, new Promise((resolve, reject) => {
      __privateSet(this, _resolve, resolve);
      __privateSet(this, _reject, reject);
      const onResolve = (value) => {
        var _a;
        if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
          return;
        }
        __privateSet(this, _isResolved, true);
        (_a = __privateGet(this, _resolve)) == null ? void 0 : _a.call(this, value);
      };
      const onReject = (reason) => {
        var _a;
        if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
          return;
        }
        __privateSet(this, _isRejected, true);
        (_a = __privateGet(this, _reject)) == null ? void 0 : _a.call(this, reason);
      };
      const onCancel = (cancelHandler) => {
        if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
          return;
        }
        __privateGet(this, _cancelHandlers).push(cancelHandler);
      };
      Object.defineProperty(onCancel, "isResolved", {
        get: () => __privateGet(this, _isResolved)
      });
      Object.defineProperty(onCancel, "isRejected", {
        get: () => __privateGet(this, _isRejected)
      });
      Object.defineProperty(onCancel, "isCancelled", {
        get: () => __privateGet(this, _isCancelled)
      });
      return executor(onResolve, onReject, onCancel);
    }));
  }
  get [Symbol.toStringTag]() {
    return "Cancellable Promise";
  }
  then(onFulfilled, onRejected) {
    return __privateGet(this, _promise).then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return __privateGet(this, _promise).catch(onRejected);
  }
  finally(onFinally) {
    return __privateGet(this, _promise).finally(onFinally);
  }
  cancel() {
    var _a;
    if (__privateGet(this, _isResolved) || __privateGet(this, _isRejected) || __privateGet(this, _isCancelled)) {
      return;
    }
    __privateSet(this, _isCancelled, true);
    if (__privateGet(this, _cancelHandlers).length) {
      try {
        for (const cancelHandler of __privateGet(this, _cancelHandlers)) {
          cancelHandler();
        }
      } catch (error) {
        console.warn("Cancellation threw an error", error);
        return;
      }
    }
    __privateGet(this, _cancelHandlers).length = 0;
    (_a = __privateGet(this, _reject)) == null ? void 0 : _a.call(this, new CancelError("Request aborted"));
  }
  get isCancelled() {
    return __privateGet(this, _isCancelled);
  }
}
_isResolved = new WeakMap();
_isRejected = new WeakMap();
_isCancelled = new WeakMap();
_cancelHandlers = new WeakMap();
_promise = new WeakMap();
_resolve = new WeakMap();
_reject = new WeakMap();

const OpenAPI = {
  BASE: "/service/rest",
  VERSION: "3.58.1-02",
  WITH_CREDENTIALS: false,
  CREDENTIALS: "include",
  TOKEN: void 0,
  USERNAME: void 0,
  PASSWORD: void 0,
  HEADERS: void 0,
  ENCODE_PATH: void 0
};

const isDefined = (value) => {
  return value !== void 0 && value !== null;
};
const isString = (value) => {
  return typeof value === "string";
};
const isStringWithValue = (value) => {
  return isString(value) && value !== "";
};
const isBlob = (value) => {
  return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
const isFormData = (value) => {
  return value instanceof FormData;
};
const base64 = (str) => {
  try {
    return btoa(str);
  } catch (err) {
    return Buffer.from(str).toString("base64");
  }
};
const getQueryString = (params) => {
  const qs = [];
  const append = (key, value) => {
    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  };
  const process = (key, value) => {
    if (isDefined(value)) {
      if (Array.isArray(value)) {
        value.forEach((v) => {
          process(key, v);
        });
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([k, v]) => {
          process(`${key}[${k}]`, v);
        });
      } else {
        append(key, value);
      }
    }
  };
  Object.entries(params).forEach(([key, value]) => {
    process(key, value);
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
};
const getUrl = (config, options) => {
  const encoder = config.ENCODE_PATH || encodeURI;
  const path = options.url.replace("{api-version}", config.VERSION).replace(/{(.*?)}/g, (substring, group) => {
    var _a;
    if ((_a = options.path) == null ? void 0 : _a.hasOwnProperty(group)) {
      return encoder(String(options.path[group]));
    }
    return substring;
  });
  const url = `${config.BASE}${path}`;
  if (options.query) {
    return `${url}${getQueryString(options.query)}`;
  }
  return url;
};
const getFormData = (options) => {
  if (options.formData) {
    const formData = new FormData();
    const process = (key, value) => {
      if (isString(value) || isBlob(value)) {
        formData.append(key, value);
      } else {
        formData.append(key, JSON.stringify(value));
      }
    };
    Object.entries(options.formData).filter(([_, value]) => isDefined(value)).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => process(key, v));
      } else {
        process(key, value);
      }
    });
    return formData;
  }
  return void 0;
};
const resolve = async (options, resolver) => {
  if (typeof resolver === "function") {
    return resolver(options);
  }
  return resolver;
};
const getHeaders = async (config, options) => {
  const token = await resolve(options, config.TOKEN);
  const username = await resolve(options, config.USERNAME);
  const password = await resolve(options, config.PASSWORD);
  const additionalHeaders = await resolve(options, config.HEADERS);
  const headers = Object.entries({
    Accept: "application/json",
    ...additionalHeaders,
    ...options.headers
  }).filter(([_, value]) => isDefined(value)).reduce((headers2, [key, value]) => ({
    ...headers2,
    [key]: String(value)
  }), {});
  if (isStringWithValue(token)) {
    headers["Authorization"] = `Bearer ${token}`;
  }
  if (isStringWithValue(username) && isStringWithValue(password)) {
    const credentials = base64(`${username}:${password}`);
    headers["Authorization"] = `Basic ${credentials}`;
  }
  if (options.body) {
    if (options.mediaType) {
      headers["Content-Type"] = options.mediaType;
    } else if (isBlob(options.body)) {
      headers["Content-Type"] = options.body.type || "application/octet-stream";
    } else if (isString(options.body)) {
      headers["Content-Type"] = "text/plain";
    } else if (!isFormData(options.body)) {
      headers["Content-Type"] = "application/json";
    }
  }
  return new Headers(headers);
};
const getRequestBody = (options) => {
  var _a;
  if (options.body !== void 0) {
    if ((_a = options.mediaType) == null ? void 0 : _a.includes("/json")) {
      return JSON.stringify(options.body);
    } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {
      return options.body;
    } else {
      return JSON.stringify(options.body);
    }
  }
  return void 0;
};
const sendRequest = async (config, options, url, body, formData, headers, onCancel) => {
  const controller = new AbortController();
  const request2 = {
    headers,
    body: body != null ? body : formData,
    method: options.method,
    signal: controller.signal
  };
  if (config.WITH_CREDENTIALS) {
    request2.credentials = config.CREDENTIALS;
  }
  onCancel(() => controller.abort());
  return await fetch(url, request2);
};
const getResponseHeader = (response, responseHeader) => {
  if (responseHeader) {
    const content = response.headers.get(responseHeader);
    if (isString(content)) {
      return content;
    }
  }
  return void 0;
};
const getResponseBody = async (response) => {
  if (response.status !== 204) {
    try {
      const contentType = response.headers.get("Content-Type");
      if (contentType) {
        const jsonTypes = ["application/json", "application/problem+json"];
        const isJSON = jsonTypes.some((type) => contentType.toLowerCase().startsWith(type));
        if (isJSON) {
          return await response.json();
        } else {
          return await response.text();
        }
      }
    } catch (error) {
      console.error(error);
    }
  }
  return void 0;
};
const catchErrorCodes = (options, result) => {
  var _a, _b;
  const errors = {
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    502: "Bad Gateway",
    503: "Service Unavailable",
    ...options.errors
  };
  const error = errors[result.status];
  if (error) {
    throw new ApiError(options, result, error);
  }
  if (!result.ok) {
    const errorStatus = (_a = result.status) != null ? _a : "unknown";
    const errorStatusText = (_b = result.statusText) != null ? _b : "unknown";
    const errorBody = (() => {
      try {
        return JSON.stringify(result.body, null, 2);
      } catch (e) {
        return void 0;
      }
    })();
    throw new ApiError(
      options,
      result,
      `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`
    );
  }
};
const request = (config, options) => {
  return new CancelablePromise(async (resolve2, reject, onCancel) => {
    try {
      const url = getUrl(config, options);
      const formData = getFormData(options);
      const body = getRequestBody(options);
      const headers = await getHeaders(config, options);
      if (!onCancel.isCancelled) {
        const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
        const responseBody = await getResponseBody(response);
        const responseHeader = getResponseHeader(response, options.responseHeader);
        const result = {
          url,
          ok: response.ok,
          status: response.status,
          statusText: response.statusText,
          body: responseHeader != null ? responseHeader : responseBody
        };
        catchErrorCodes(options, result);
        resolve2(result.body);
      }
    } catch (error) {
      reject(error);
    }
  });
};

class SearchService {
  /**
   * Search assets
   * @returns PageAssetXO successful operation
   * @throws ApiError
   */
  static searchAssets({
    continuationToken,
    sort,
    direction,
    timeout,
    q,
    repository,
    format,
    group,
    name,
    version,
    prerelease,
    md5,
    sha1,
    sha256,
    sha512,
    conanBaseVersion,
    conanChannel,
    conanRevision,
    conanPackageId,
    conanPackageRevision,
    dockerImageName,
    dockerImageTag,
    dockerLayerId,
    dockerContentDigest,
    mavenGroupId,
    mavenArtifactId,
    mavenBaseVersion,
    mavenExtension,
    mavenClassifier,
    gavec,
    npmScope,
    npmAuthor,
    npmDescription,
    npmKeywords,
    npmLicense,
    npmTaggedIs,
    npmTaggedNot,
    nugetId,
    nugetTags,
    nugetTitle,
    nugetAuthors,
    nugetDescription,
    nugetSummary,
    p2PluginName,
    pypiClassifiers,
    pypiDescription,
    pypiKeywords,
    pypiSummary,
    rubygemsDescription,
    rubygemsPlatform,
    rubygemsSummary,
    yumArchitecture,
    yumName
  }) {
    return request(OpenAPI, {
      method: "GET",
      url: "/v1/search/assets",
      query: {
        "continuationToken": continuationToken,
        "sort": sort,
        "direction": direction,
        "timeout": timeout,
        "q": q,
        "repository": repository,
        "format": format,
        "group": group,
        "name": name,
        "version": version,
        "prerelease": prerelease,
        "md5": md5,
        "sha1": sha1,
        "sha256": sha256,
        "sha512": sha512,
        "conan.baseVersion": conanBaseVersion,
        "conan.channel": conanChannel,
        "conan.revision": conanRevision,
        "conan.packageId": conanPackageId,
        "conan.packageRevision": conanPackageRevision,
        "docker.imageName": dockerImageName,
        "docker.imageTag": dockerImageTag,
        "docker.layerId": dockerLayerId,
        "docker.contentDigest": dockerContentDigest,
        "maven.groupId": mavenGroupId,
        "maven.artifactId": mavenArtifactId,
        "maven.baseVersion": mavenBaseVersion,
        "maven.extension": mavenExtension,
        "maven.classifier": mavenClassifier,
        "gavec": gavec,
        "npm.scope": npmScope,
        "npm.author": npmAuthor,
        "npm.description": npmDescription,
        "npm.keywords": npmKeywords,
        "npm.license": npmLicense,
        "npm.tagged_is": npmTaggedIs,
        "npm.tagged_not": npmTaggedNot,
        "nuget.id": nugetId,
        "nuget.tags": nugetTags,
        "nuget.title": nugetTitle,
        "nuget.authors": nugetAuthors,
        "nuget.description": nugetDescription,
        "nuget.summary": nugetSummary,
        "p2.pluginName": p2PluginName,
        "pypi.classifiers": pypiClassifiers,
        "pypi.description": pypiDescription,
        "pypi.keywords": pypiKeywords,
        "pypi.summary": pypiSummary,
        "rubygems.description": rubygemsDescription,
        "rubygems.platform": rubygemsPlatform,
        "rubygems.summary": rubygemsSummary,
        "yum.architecture": yumArchitecture,
        "yum.name": yumName
      }
    });
  }
  /**
   * Search and download asset
   * Returns a 302 Found with location header field set to download URL. Unless a sort parameter is supplied, the search must return a single asset to receive download URL.
   * @returns void
   * @throws ApiError
   */
  static searchAndDownloadAssets({
    sort,
    direction,
    timeout,
    q,
    repository,
    format,
    group,
    name,
    version,
    prerelease,
    md5,
    sha1,
    sha256,
    sha512,
    conanBaseVersion,
    conanChannel,
    conanRevision,
    conanPackageId,
    conanPackageRevision,
    dockerImageName,
    dockerImageTag,
    dockerLayerId,
    dockerContentDigest,
    mavenGroupId,
    mavenArtifactId,
    mavenBaseVersion,
    mavenExtension,
    mavenClassifier,
    gavec,
    npmScope,
    npmAuthor,
    npmDescription,
    npmKeywords,
    npmLicense,
    npmTaggedIs,
    npmTaggedNot,
    nugetId,
    nugetTags,
    nugetTitle,
    nugetAuthors,
    nugetDescription,
    nugetSummary,
    p2PluginName,
    pypiClassifiers,
    pypiDescription,
    pypiKeywords,
    pypiSummary,
    rubygemsDescription,
    rubygemsPlatform,
    rubygemsSummary,
    yumArchitecture,
    yumName
  }) {
    return request(OpenAPI, {
      method: "GET",
      url: "/v1/search/assets/download",
      query: {
        "sort": sort,
        "direction": direction,
        "timeout": timeout,
        "q": q,
        "repository": repository,
        "format": format,
        "group": group,
        "name": name,
        "version": version,
        "prerelease": prerelease,
        "md5": md5,
        "sha1": sha1,
        "sha256": sha256,
        "sha512": sha512,
        "conan.baseVersion": conanBaseVersion,
        "conan.channel": conanChannel,
        "conan.revision": conanRevision,
        "conan.packageId": conanPackageId,
        "conan.packageRevision": conanPackageRevision,
        "docker.imageName": dockerImageName,
        "docker.imageTag": dockerImageTag,
        "docker.layerId": dockerLayerId,
        "docker.contentDigest": dockerContentDigest,
        "maven.groupId": mavenGroupId,
        "maven.artifactId": mavenArtifactId,
        "maven.baseVersion": mavenBaseVersion,
        "maven.extension": mavenExtension,
        "maven.classifier": mavenClassifier,
        "gavec": gavec,
        "npm.scope": npmScope,
        "npm.author": npmAuthor,
        "npm.description": npmDescription,
        "npm.keywords": npmKeywords,
        "npm.license": npmLicense,
        "npm.tagged_is": npmTaggedIs,
        "npm.tagged_not": npmTaggedNot,
        "nuget.id": nugetId,
        "nuget.tags": nugetTags,
        "nuget.title": nugetTitle,
        "nuget.authors": nugetAuthors,
        "nuget.description": nugetDescription,
        "nuget.summary": nugetSummary,
        "p2.pluginName": p2PluginName,
        "pypi.classifiers": pypiClassifiers,
        "pypi.description": pypiDescription,
        "pypi.keywords": pypiKeywords,
        "pypi.summary": pypiSummary,
        "rubygems.description": rubygemsDescription,
        "rubygems.platform": rubygemsPlatform,
        "rubygems.summary": rubygemsSummary,
        "yum.architecture": yumArchitecture,
        "yum.name": yumName
      },
      errors: {
        400: `ValidationErrorXO{id='*', message='Search returned multiple assets, please refine search criteria to find a single asset or use the sort query parameter to retrieve the first result.'}`,
        404: `Asset search returned no results`
      }
    });
  }
  /**
   * Search components
   * @returns PageComponentXO successful operation
   * @throws ApiError
   */
  static search({
    continuationToken,
    sort,
    direction,
    timeout,
    q,
    repository,
    format,
    group,
    name,
    version,
    prerelease,
    md5,
    sha1,
    sha256,
    sha512,
    conanBaseVersion,
    conanChannel,
    conanRevision,
    conanPackageId,
    conanPackageRevision,
    dockerImageName,
    dockerImageTag,
    dockerLayerId,
    dockerContentDigest,
    mavenGroupId,
    mavenArtifactId,
    mavenBaseVersion,
    mavenExtension,
    mavenClassifier,
    gavec,
    npmScope,
    npmAuthor,
    npmDescription,
    npmKeywords,
    npmLicense,
    npmTaggedIs,
    npmTaggedNot,
    nugetId,
    nugetTags,
    nugetTitle,
    nugetAuthors,
    nugetDescription,
    nugetSummary,
    p2PluginName,
    pypiClassifiers,
    pypiDescription,
    pypiKeywords,
    pypiSummary,
    rubygemsDescription,
    rubygemsPlatform,
    rubygemsSummary,
    yumArchitecture,
    yumName
  }) {
    return request(OpenAPI, {
      method: "GET",
      url: "/v1/search",
      query: {
        "continuationToken": continuationToken,
        "sort": sort,
        "direction": direction,
        "timeout": timeout,
        "q": q,
        "repository": repository,
        "format": format,
        "group": group,
        "name": name,
        "version": version,
        "prerelease": prerelease,
        "md5": md5,
        "sha1": sha1,
        "sha256": sha256,
        "sha512": sha512,
        "conan.baseVersion": conanBaseVersion,
        "conan.channel": conanChannel,
        "conan.revision": conanRevision,
        "conan.packageId": conanPackageId,
        "conan.packageRevision": conanPackageRevision,
        "docker.imageName": dockerImageName,
        "docker.imageTag": dockerImageTag,
        "docker.layerId": dockerLayerId,
        "docker.contentDigest": dockerContentDigest,
        "maven.groupId": mavenGroupId,
        "maven.artifactId": mavenArtifactId,
        "maven.baseVersion": mavenBaseVersion,
        "maven.extension": mavenExtension,
        "maven.classifier": mavenClassifier,
        "gavec": gavec,
        "npm.scope": npmScope,
        "npm.author": npmAuthor,
        "npm.description": npmDescription,
        "npm.keywords": npmKeywords,
        "npm.license": npmLicense,
        "npm.tagged_is": npmTaggedIs,
        "npm.tagged_not": npmTaggedNot,
        "nuget.id": nugetId,
        "nuget.tags": nugetTags,
        "nuget.title": nugetTitle,
        "nuget.authors": nugetAuthors,
        "nuget.description": nugetDescription,
        "nuget.summary": nugetSummary,
        "p2.pluginName": p2PluginName,
        "pypi.classifiers": pypiClassifiers,
        "pypi.description": pypiDescription,
        "pypi.keywords": pypiKeywords,
        "pypi.summary": pypiSummary,
        "rubygems.description": rubygemsDescription,
        "rubygems.platform": rubygemsPlatform,
        "rubygems.summary": rubygemsSummary,
        "yum.architecture": yumArchitecture,
        "yum.name": yumName
      }
    });
  }
}

const MAVEN_IGNORED_ASSET_EXTENSIONS = /* @__PURE__ */ new Set([
  "pom",
  "sha1",
  "md5",
  "sha256"
]);
function isPrimaryAsset(asset) {
  var _a;
  if (!asset.maven2) {
    return true;
  }
  const { extension } = asset.maven2;
  if (extension === void 0) {
    return true;
  }
  return !MAVEN_IGNORED_ASSET_EXTENSIONS.has((_a = extension.split(".").pop()) != null ? _a : "");
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const DEFAULT_PROXY_PATH = "/nexus-repository-manager";
const NEXUS_REPOSITORY_MANAGER_CONFIG = {
  proxyPath: "nexusRepositoryManager.proxyPath",
  experimentalAnnotations: "nexusRepositoryManager.experimentalAnnotations"
};
const DOCKER_MANIFEST_HEADERS = {
  Accept: [
    "application/vnd.docker.distribution.manifest.v2+json",
    "application/vnd.docker.distribution.manifest.v1+json;q=0.9",
    "*/*;q=0.8"
  ].join(", ")
};
function getAdditionalHeaders(format) {
  switch (format) {
    case "docker":
      return DOCKER_MANIFEST_HEADERS;
    default:
      return {};
  }
}
function shouldFetchSize(asset) {
  if (asset.format !== "maven2") {
    return false;
  }
  if (!asset.maven2) {
    return false;
  }
  return (
    // Choosing not to care about the size of e.g. sources or javadoc
    asset.maven2.classifier || !isPrimaryAsset(asset)
  );
}
const NexusRepositoryManagerApiRef = createApiRef({
  id: "plugin.nexus-repository-manager.service"
});
class NexusRepositoryManagerApiClient {
  constructor(options) {
    __publicField(this, "discoveryApi");
    __publicField(this, "configApi");
    __publicField(this, "identityApi");
    __publicField(this, "baseUrl", "");
    this.discoveryApi = options.discoveryApi;
    this.configApi = options.configApi;
    this.identityApi = options.identityApi;
  }
  async getBaseUrl() {
    var _a;
    if (this.baseUrl) {
      return this.baseUrl;
    }
    const proxyPath = (_a = this.configApi.getOptionalString(
      NEXUS_REPOSITORY_MANAGER_CONFIG.proxyPath
    )) != null ? _a : DEFAULT_PROXY_PATH;
    this.baseUrl = `${await this.discoveryApi.getBaseUrl("proxy")}${proxyPath}`;
    return this.baseUrl;
  }
  async proxiedDownloadUrl(asset) {
    const proxyUrl = await this.getBaseUrl();
    return `${proxyUrl}/repository/${asset.repository}/${asset.path}`;
  }
  async searchServiceFetcher(url, query) {
    const { token: idToken } = await this.identityApi.getCredentials();
    OpenAPI.BASE = url;
    OpenAPI.TOKEN = idToken;
    return await SearchService.search(query);
  }
  async fetcher(url, additionalHeaders = {}, method = "GET") {
    const { token: idToken } = await this.identityApi.getCredentials();
    const headers = new Headers(additionalHeaders);
    if (idToken) {
      headers.set("Authorization", `Bearer ${idToken}`);
    }
    const response = await fetch(url, { headers, method });
    if (!response.ok) {
      throw new Error(
        `failed to fetch data, status ${response.status}: ${response.statusText}`
      );
    }
    return response;
  }
  /**
   * Use HEAD requests to get the size of each asset we care about, as nexus
   * doesn't return that information in the search API.
   * Only supports maven for now.
   */
  async addFileSizes(component) {
    if (component.format !== "maven2" || !component.assets) {
      return component;
    }
    const headers = getAdditionalHeaders(component.format);
    const updatedAssets = await Promise.all(
      component.assets.map(async (asset) => {
        if (asset.fileSize !== 0 || shouldFetchSize(asset)) {
          return asset;
        }
        const response = await this.fetcher(
          await this.proxiedDownloadUrl(asset),
          headers,
          "HEAD"
        );
        return {
          ...asset,
          fileSize: Number(response.headers.get("Content-Length")) || 0
        };
      })
    );
    return {
      ...component,
      assets: updatedAssets
    };
  }
  async getDockerManifests(component) {
    var _a, _b;
    if (component.format !== "docker") {
      return [];
    }
    const additionalHeaders = getAdditionalHeaders(component.format);
    const assets = await Promise.all(
      (_b = (_a = component.assets) == null ? void 0 : _a.map(
        async (asset) => (await this.fetcher(
          await this.proxiedDownloadUrl(asset),
          additionalHeaders
        )).json()
      )) != null ? _b : [new Promise(() => null)]
    );
    return assets;
  }
  async getComponents(query) {
    var _a;
    const proxyUrl = await this.getBaseUrl();
    const components = [];
    let continuationToken;
    do {
      const res = await this.searchServiceFetcher(`${proxyUrl}/service/rest`, {
        ...query,
        continuationToken
      });
      continuationToken = res.continuationToken;
      components.push(...(_a = res.items) != null ? _a : []);
    } while (continuationToken);
    const values = await Promise.all(
      components.map(async (component) => ({
        component: await this.addFileSizes(component),
        dockerManifests: await this.getDockerManifests(component)
      }))
    );
    const filteredValues = values.filter(
      (v) => {
        var _a2, _b;
        return (_b = (_a2 = v.component) == null ? void 0 : _a2.assets) == null ? void 0 : _b.some((asset) => isPrimaryAsset(asset));
      }
    );
    return {
      components: filteredValues
    };
  }
  getAnnotations() {
    const usesExperimental = this.configApi.getOptionalBoolean(
      NEXUS_REPOSITORY_MANAGER_CONFIG.experimentalAnnotations
    );
    if (usesExperimental) {
      return {
        ANNOTATIONS: [
          ...NEXUS_REPOSITORY_MANAGER_ANNOTATIONS,
          ...NEXUS_REPOSITORY_MANAGER_EXPERIMENTAL_ANNOTATIONS
        ]
      };
    }
    return { ANNOTATIONS: NEXUS_REPOSITORY_MANAGER_ANNOTATIONS };
  }
}

const rootRouteRef = createRouteRef({
  id: "nexus-repository-manager"
});

const nexusRepositoryManagerPlugin = createPlugin({
  id: "nexus-repository-manager",
  routes: {
    root: rootRouteRef
  },
  apis: [
    createApiFactory({
      api: NexusRepositoryManagerApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        configApi: configApiRef,
        identityApi: identityApiRef
      },
      factory: ({ discoveryApi, configApi, identityApi }) => new NexusRepositoryManagerApiClient({
        discoveryApi,
        configApi,
        identityApi
      })
    })
  ]
});
const NexusRepositoryManagerPage = nexusRepositoryManagerPlugin.provide(
  createComponentExtension({
    name: "NexusRepositoryManagerPage",
    component: {
      lazy: () => import('./index-4216f1c9.esm.js').then((m) => m.NexusRepositoryManager)
    }
  })
);
const isNexusRepositoryManagerAvailable = (entity) => NEXUS_REPOSITORY_MANAGER_ANNOTATIONS.some(
  (value) => {
    var _a;
    return Boolean((_a = entity.metadata.annotations) == null ? void 0 : _a[value.annotation]);
  }
);
const isNexusRepositoryManagerExperimentalAvailable = (entity) => isNexusRepositoryManagerAvailable(entity) || NEXUS_REPOSITORY_MANAGER_EXPERIMENTAL_ANNOTATIONS.some(
  (value) => {
    var _a;
    return Boolean((_a = entity.metadata.annotations) == null ? void 0 : _a[value.annotation]);
  }
);

export { NEXUS_REPOSITORY_MANAGER_CONFIG_ANNOTATIONS as N, NexusRepositoryManagerApiRef as a, NexusRepositoryManagerPage as b, isNexusRepositoryManagerAvailable as c, isNexusRepositoryManagerExperimentalAvailable as d, isPrimaryAsset as i, nexusRepositoryManagerPlugin as n };
//# sourceMappingURL=index-496595d6.esm.js.map
